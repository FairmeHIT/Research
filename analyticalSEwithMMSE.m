%The function can be used to calculate the analytical result of SE_k[n] 
%according to Theorem 1 in the manuscript:
 
%Huafu Li, Yang Wang, Chenyang Sun, and Zhenyong Wang, "User-Centric
%Cell-Free Massive MIMO for IoT in Highly Dynamic Environments", submitted
%to IoTJ on May 29th, 2023.

%Input:
% K -> Number of UEs for the cell-free systems
% M -> Antenna number of AP
% L -> Number of APs    
% U -> Serving AP indicator matrix, U(k,l)=1 means that l is the serving AP of k, generated by (54), [K×L] matrix 
% P -> Transmit power of UE in W, [K×1] vector
% Ghat_MMSE -> Estimate channel matrix generated by <channelEstimateMMSE.m>, [M*L×N×K] matrix 
% HMean -> Channel mean matrix generated by Eq.(1), [M×N×L×K] matrix 
% Omega -> Spatial correlation matrix generated by <scfGenerate.m>, [M×M×L×K] matrix 
% R -> Spatial correlation matrix generated by <scfGenerate.m>, [M×M×L×K] matrix 
% B_MMSE -> Estimate covariance matrix with MMSE estimator generated by <channelEstimateMMSE.m>, [M*L×N×K] matrix
% pIndex -> Pilot index assigned to UE, [K×1] vector
% ACF_1_d -> ACF_1 for S=[T+1:C] generated by <scfGenerate.m>, [K×L×T] vector
% ACF_1_t -> ACF_1 for S=[1+T] generated by <scfGenerate.m>, [K×L×T] vector
% a_h -> Wave vector generated by Eq.(2), [M×L×K] vector
% n -> n-th symbol of transmission phase
  
%Output:
% SE_analytical_kn_Theorem1, MMSE estimator, SE at $n$-th symbol, [K×1] vector   

function [SE_analytical_kn_Theorem1] = analyticalSEwithMMSE(K,M,L,U,P,Ghat_MMSE,HMean,Omega,R,B_MMSE,pIndex,ACF_1_d,ACF_1_t,a_h,n)
 
%Prepare to store
GAging = zeros(size(Ghat_MMSE));  
B_Aging = zeros(size(B_MMSE));   
for k = 1:K 
    for l = 1:L
        %intermediate variable
        GAging((l-1)*M_AP+1:l*M_AP,:,k) = ACF_1_d(k,l,n)*Ghat_MMSE((l-1)*M+1:l*M,:,k) + HMean(:,:,l,k);
        B_Aging(:,:,l,k) = (abs(ACF_1_d(k,l,n)))^2 * B_MMSE(:,:,l,k); 
    end
end
 
%Prepare to store the terms that appear in SEs
los_a_2 = zeros(K,L,K);
los_a_1 = zeros(K,L,K);
Nois = zeros(L,K);  
%Prepare to store the SE results
%MR combining
SE_analytical_kn_Theorem1 = zeros(K,1);
  
%Compute the closed-form expression according to Theorem 1
%Go through each AP
for l = 1:L
    %Extract which UEs are served by the AP l
    UEs_index = find(U(:,l)==1); 
    %Go through all UEs served by the AP l
    for UE_i = 1:length(UEs_index) 
        %Extract UE index
        k = UEs_index(UE_i); 
        %for C_ki^{los-a,(1)}, Eq.(57)
        Nois(l,k) = a_h(:,l,k)'*a_h(:,l,k) + trace(B_Aging(:,:,l,k)); 
        %Compute the received pilot signal covariance matrix Psi
        Psi = (P*sum(R(:,:,l,pIndex(k)==pIndex),4) + eyeM); 
        %Go through all UEs
        for i = 1:K
            %Eq.(59)
            los_a_1(i,l,k) =   trace( (Omega(:,:,l,i)) * (a_h(:,l,k)*a_h(:,l,k)' + B_Aging(:,:,l,k)) ); 
            %Eq.(65)
            los_a_2(i,l,k) = a_h(:,l,k)'*a_h(:,l,i); 
            %If UE i shares the same pilot with UE k
            if pIndex(k) == pIndex(i)  
                %Eq.(43)
                rho_l = P * ACF_1_d(k,l,n)'*ACF_1_t(i,l,pIndex(k))'*ACF_1_t(k,l,pIndex(k))*ACF_1_d(i,l,n); 
                %Nondiagonal element with pilot contamination, Eq.(65)
                los_a_2(i,l,k) = los_a_2(i,l,k) + (rho_l) * (trace(R(:,:,l,k)*Psi^(-1)*R(:,:,l,i))); 
                %Diagonal element with pilot contamination, Eq.(64)
                los_a_1(i,l,k) = los_a_1(i,l,k) + abs((rho_l) * trace(R(:,:,l,i)*Psi^(-1)*R(:,:,l,k)))^2 ...
                    + 2*real(rho_l*trace(R(:,:,l,i)*Psi^(-1)*R(:,:,l,k)) * a_h(:,l,i)'*a_h(:,l,k) )  ; 
            end
        end
    end
end 
% Compute the SE according to the above results
for k = 1:K 
    %Determine the set of serving APs for UE k
    seAPs = find(U(k,:)==1); 
    vec_temp = vec(sqrt(P)*los_a_2(k,seAPs,k)); 
    %Compute C_ki^{los-a}-(b_kk^{los-a}(b_kk^{los-a})^H) matrix for SE
    Mat_temp =  los_a_2(:,seAPs,k).'*conj(los_a_2(:,seAPs,k));
    Cki_matrix = P*(diag(sum(los_a_1(:,seAPs,k),1))+Mat_temp-diag(diag(Mat_temp)))...
        -vec_temp*vec_temp'+diag(Nois(seAPs,k)); 
    %Compute the LSFD vector 
    a_k = Cki_matrix\vec_temp; 
    %Compute the SE for symbol n 
    SE_analytical_kn_Theorem1(k) = real(log2(1+abs(a_k'*vec_temp)^2/(a_k'*Cki_matrix*a_k))); 
end